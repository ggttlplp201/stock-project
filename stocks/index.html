<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Stock & Crypto Viewer</title>
  <style>
    :root { --bg:#f5f7fa; --card:#fff; --txt:#222; --muted:#666; --brand:#0077ff; --brand-d:#005fcc; }
    * { box-sizing: border-box; }
    body { margin:0; padding:2rem; font-family:Arial, sans-serif; background:var(--bg); display:flex; justify-content:center; }
    .container { width:100%; max-width:1100px; }
    h1 { text-align:center; color:var(--txt); margin:0 0 .25rem; }
    .sub { text-align:center; color:var(--muted); margin-bottom:1.25rem; }

    /* Tabs */
    .tabs { display:flex; gap:8px; justify-content:center; margin: 1rem 0 1.25rem; }
    .tab-btn { padding:.6rem 1rem; border:1px solid #cfd6e4; background:#e9eef6; color:#24324a; border-radius:8px; cursor:pointer; }
    .tab-btn.active { background:var(--brand); color:#fff; border-color:var(--brand); }

    /* AI picks */
    .rec-wrap { margin-bottom: 1.25rem; }
    .rec-header { display:flex; justify-content:space-between; margin-bottom:.5rem; align-items:center; }
    .rec-title { font-weight:700; }
    .rec-grid { display:grid; grid-template-columns:repeat(auto-fill, minmax(220px,1fr)); gap:12px; }
    .rec-card { background:var(--card); border-radius:10px; padding:12px; box-shadow:0 6px 18px rgba(0,0,0,.08); cursor:pointer; transition:.2s; }
    .rec-card:hover { transform:translateY(-2px); box-shadow:0 10px 22px rgba(0,0,0,.12); }
    .rec-symbol { font-weight:700; }
    .rec-reason { margin-top:8px; font-size:.95rem; color:#333; }

    /* Forms */
    .form-row { display:flex; gap:10px; margin-bottom:1rem; justify-content:center; flex-wrap:wrap; }
    input, select { padding:10px; font-size:1rem; border:1px solid #ccc; border-radius:8px; }
    .btn { padding:10px 16px; font-size:1rem; border:0; border-radius:8px; background:var(--brand); color:#fff; cursor:pointer; }
    .btn:hover { background:var(--brand-d); }
    .hint { text-align:center; color:var(--muted); margin-bottom: 1rem; }

    /* Cards */
    .card { background:var(--card); padding:1.2rem; border-radius:10px; box-shadow:0 6px 18px rgba(0,0,0,.08); margin-bottom:1.25rem; }
    .card h2 { margin:0 0 .5rem; }
    .error { color:#c62828; font-weight:700; }

    /* --- AI Insights --- */ 
#insights.card {
  padding: 1.25rem 1.25rem 1rem;
  background: linear-gradient(180deg, #ffffff, #f7faff);
  border: 1px solid #e7eef8;
}
.ins-head {
  display:flex; justify-content:space-between; align-items:center;
  margin: 0 0 .5rem;
}
.ins-title {
  font-size:1.1rem; font-weight:800; color:#223555; letter-spacing:.2px;
}
.ins-meta {
  font-size:.85rem; color:#6b7a90;
}
.ins-list {
  margin:.25rem 0 0; padding-left:1.1rem;
}
.ins-list li {
  margin:.35rem 0; line-height:1.55;
}
.badge {
  display:inline-block; padding:.15rem .5rem; border-radius:999px;
  background:#eef3ff; color:#3b5bdb; font-size:.75rem; border:1px solid #dbe6ff;
}


    /* Chart */
    .tv-wrap { background:var(--card); border-radius:10px; box-shadow:0 6px 18px rgba(0,0,0,.08); padding:1rem; }
    .tv-container { width:100%; height:600px; }

    .hidden { display:none; }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ“ˆ Stock & Crypto Viewer</h1>

    <!-- Tabs -->
    <div class="tabs">
      <button id="tab-stocks" class="tab-btn active">Stocks</button>
      <button id="tab-crypto" class="tab-btn">Crypto</button>
    </div>

    <!-- Stocks -->
    <section id="panel-stocks">
      <div class="rec-wrap">
        <div class="rec-header">
          <div class="rec-title">AI Picks</div>
          <div id="rec-status" class="rec-hint">Generating picksâ€¦</div>
        </div>
        <div id="rec-grid" class="rec-grid"></div>
      </div>

      <form id="stock-form" class="form-row">
        <input type="text" id="symbol" required placeholder="e.g., AAPL or TSLA" />
        <button class="btn" type="submit">Get Quote</button>
      </form>

      <div id="result" class="card"></div>
    </section>

    <!-- Crypto -->
    <section id="panel-crypto" class="hidden">
      <form id="crypto-form" class="form-row">
        <input type="text" id="cryptoSymbol" required placeholder="Symbol (e.g., BTC, ETH)" />
        <select id="cryptoMarket">
          <option value="USD" selected>USD</option>
          <option value="USDT">USDT</option>
          <option value="EUR">EUR</option>
        </select>
        <select id="cryptoExchange">
          <option value="COINBASE" selected>Coinbase (USD)</option>
          <option value="BINANCE">Binance (USDT)</option>
        </select>
        <button class="btn" type="submit">Get Crypto</button>
      </form>
      <div class="hint">Realtime rate from Alpha Vantage; chart uses selected exchange (Coinbase = USD, Binance = USDT).</div>

      <div id="crypto-result" class="card"></div>
    </section>

    <!-- Chart -->
    <div class="tv-wrap">
      
      <h2 id="chart-title" style="margin:0 0 .5rem;">Interactive Chart</h2>
      <div id="tv_chart_container" class="tv-container"></div>
    </div>

    <!-- AI Insights -->
    <div id="insights" class="card">
  <div class="ins-head">
    <div class="ins-title">AI Insights</div>
    <div class="ins-meta" id="insights-meta"><span class="badge">loadingâ€¦</span></div>
  </div>
  <div id="insights-body" class="hint">An AI summary for the current chart will appear here.</div>
</div>

  </div>

  <!-- TradingView -->
  <script src="https://s3.tradingview.com/tv.js"></script>
  <script>
    /* ========= Config ========= */
    const AV_API_KEY   = 'MXW8J9FLMSVW8FAW';    // Alpha Vantage
    const PROXY_URL    = "/api/chat";           // Your OpenAI proxy endpoint
    const OPENAI_MODEL = "gpt-4o-mini";
    /* ========= AI Insights (auto on every symbol) ========= */
    const INSIGHTS_LANG = 'English';                 // éœ€è¦ä¸­æ–‡å¯ä»¥æ”¹æˆ 'Chinese'
    const INS_CACHE_TTL = 6 * 60 * 60 * 1000;        // 6 å°æ—¶ç¼“å­˜

    // --- Time helpers for Binance kline ---
function toMs(t){
  // æ”¯æŒä¼ å…¥ Date / ISO å­—ç¬¦ä¸² / ms æ•°å­— / ç©º
  if (!t) return undefined;
  if (typeof t === 'number') return t;
  const d = (t instanceof Date) ? t : new Date(t);
  const ms = d.getTime();
  return Number.isFinite(ms) ? ms : undefined;
}


function setInsights(html) {
  document.getElementById('insights-body').innerHTML = html;
}
function seriesToLines(series) {
  // ä»…ä¿ç•™æœ€è¿‘ 120 æ ¹ï¼ŒæŒ‰æ—¶é—´ä»æ—§åˆ°æ–°
  return series.slice(-120).map(c =>
    `${c.t},O${c.o},H${c.h},L${c.l},C${c.c},V${c.v}`
  ).join('\n');
}
// å°†æ¨¡å‹è¿”å›çš„çº¯æ–‡æœ¬è½¬æˆåˆ—è¡¨ï¼ˆæ”¯æŒä»¥ "- " å¼€å¤´çš„è¡Œï¼‰
function renderInsightsText(text){
  if (!text) return '<span class="hint">No insights.</span>';
  const lines = text.split('\n').map(s=>s.trim()).filter(Boolean);
  const bullets = lines.every(l => l.startsWith('- '));
  if (bullets) {
    const items = lines.map(l => `<li>${l.replace(/^- /,'')}</li>`).join('');
    return `<ul class="ins-list">${items}</ul>`;
  }
  // å›é€€ï¼šæ™®é€šæ®µè½
  return `<div style="line-height:1.6">${text.replace(/\n/g,'<br>')}</div>`;
}

function setInsights(html, { meta } = {}){
  document.getElementById('insights-body').innerHTML = html;
  if (meta) document.getElementById('insights-meta').innerHTML = meta;
}

function seriesToLines(series){
  // ä»…ä¿ç•™æœ€è¿‘120æ ¹ï¼ˆå¤ŸAIåˆ¤æ–­ï¼‰ï¼Œå¹¶è½¬æˆç®€æ´çš„ OHLCV æ–‡æœ¬è¡¨æ ¼
  return series.slice(-120).map(c =>
    `${c.t},O${c.o},H${c.h},L${c.l},C${c.c},V${c.v}`
  ).join('\n');
}

async function askAIForInsightsFromSeries(series, label, kind) {
  const lines = seriesToLines(series);
  const prompt = `You are a market analyst. Analyze the following ${kind} daily OHLCV series for ${label}.
Return 3â€“5 concise bullet points in ${INSIGHTS_LANG}: trend, momentum/volatility, notable levels/patterns, and one-sentence takeaway.
DO NOT give investment advice. Plain text bullets only.
Data (oldest to newest):
${lines}`;
  const json = await postChatWithRetry(
    { model: OPENAI_MODEL, messages:[{role:'user', content: prompt}], temperature: 0.4 },
    { retries: 2, baseDelay: 1200 }
  );
  return json?.choices?.[0]?.message?.content || '';
}
async function explainFromSeriesCached(key, seriesFetcher, label, kind){
  const cached = loadCachedRecs(key);
  if (cached){
    setInsights(renderInsightsText(cached), { meta: `<span class="badge">cached</span>` });
    return;
  }
  setInsights('Generating AI insightsâ€¦', { meta: `<span class="badge">generatingâ€¦</span>` });

  const series = await seriesFetcher();
  if (!series || series.length < 20){
    setInsights('<span class="hint">Not enough data to generate insights.</span>',
                { meta: `<span class="badge">no-data</span>` });
    return;
  }

  // ä»åºåˆ—é‡Œåˆ¤æ–­æ—¶é—´æ¡†æ¶ï¼ˆD/Wï¼‰ï¼Œæ˜¾ç¤ºåœ¨ meta
  const tf = series[series.length - 1]._tf || 'D';
  const meta = `<span class="badge">${kind} â€¢ ${tf}</span> <span class="badge">last ${Math.min(120, series.length)} bars</span>`;

  const lines = seriesToLines(series);
  const prompt = `You are a market analyst. Analyze the following ${kind} ${tf} OHLCV series for ${label}.
Return 3â€“5 concise bullet points in English: trend, momentum/volatility, notable levels/patterns, and one-sentence takeaway.
No investment advice. Bulleted list using "- ".
Data (oldest to newest):
${lines}`;

  try {
    const json = await postChatWithRetry(
      { model: OPENAI_MODEL, messages:[{role:'user', content: prompt}], temperature: 0.4 },
      { retries: 2, baseDelay: 1200 }
    );
    const text = json?.choices?.[0]?.message?.content || '';
    saveCachedRecs(key, text);
    setInsights(renderInsightsText(text), { meta });
  } catch (e){
    console.error(e);
    setInsights(`<span class="error">${e?.json?.error || e?.message || 'AI error'}</span>`,
                { meta: `<span class="badge">error</span>` });
  }
}


/* ---- è·å– K çº¿ï¼šCrypto ä¼˜å…ˆ Binanceï¼Œå¤±è´¥å†å›é€€ Alpha Vantage ---- */
// Fetch candles from Binance REST (spot). Supports interval / limit / start-end paging.
async function fetchCryptoCandlesFromBinance(base, quote, {
  interval = '1d',            // å‚è€ƒ TV çš„ Dï¼›Binance ç”¨å°å†™ï¼š'1d','4h','1h'...
  limit = 500,                // æ¯æ¬¡è¯·æ±‚è¿”å›æ ¹æ•°ï¼Œ<=1000
  startTime,                  // å¯é€‰ï¼šDate|ISO|ms
  endTime                     // å¯é€‰ï¼šDate|ISO|ms
} = {}) {
  // Binance ç°è´§å¸¸ç”¨ USDTï¼›è‹¥ç”¨æˆ·é€‰ USDï¼Œåˆ™æ”¹ä¸º USDT
  const q = (quote === 'USD') ? 'USDT' : quote;
  const symbol = `${base}${q}`.toUpperCase();

  // ç»Ÿä¸€æ—¶é—´ä¸º ms
  const endMs   = toMs(endTime);
  let   cursor  = toMs(startTime);

  const out = [];
  const PAGE_LIMIT = Math.min(Math.max(1, limit|0), 1000); // 1..1000

  // å°è£…ä¸€æ¬¡è¯·æ±‚
  async function fetchPage(st) {
    const params = new URLSearchParams({
      symbol, interval, limit: String(PAGE_LIMIT)
    });
    if (st) params.set('startTime', String(st));
    if (endMs) params.set('endTime', String(endMs));

    const url = `https://api.binance.com/api/v3/klines?` + params.toString();
    const r = await fetch(url, { headers: { 'Cache-Control': 'no-cache', 'Pragma': 'no-cache' } });
    if (!r.ok) {
      const txt = await r.text();
      throw new Error(`Binance klines error ${r.status}: ${txt}`);
    }
    const arr = await r.json(); // [[openTime,open,high,low,close,volume,closeTime,...], ...]
    return arr.map(k => ({
      t: new Date(k[0]).toISOString().slice(0,10),
      o: +k[1], h: +k[2], l: +k[3], c: +k[4], v: +k[5],
      _openMs: k[0]
    }));
  }

  // è‹¥æœªç»™ startTimeï¼Œå°±æ‹‰ä¸€é¡µè¶³å¤Ÿç”¨äº AIï¼ˆä¾‹å¦‚ 500 æ ¹ï¼‰ï¼›è‹¥ç»™äº† startTimeï¼Œå°±æŒ‰æ¸¸æ ‡åˆ†é¡µ
  if (!cursor) {
    const page = await fetchPage(undefined);
    out.push(...page);
  } else {
    // åˆ†é¡µå‘åæ‹‰ç›´åˆ°åˆ° endTime æˆ–æ‹¿ä¸åˆ°æ›´å¤š
    while (true) {
      const page = await fetchPage(cursor);
      if (!page.length) break;
      out.push(...page);
      // ä¸‹ä¸€é¡µä»æœ€åä¸€æ ¹çš„ closeTime+1 å¼€å§‹ï¼ˆç”¨ openTime ä¹Ÿå¯ä»¥ï¼‰
      cursor = page[page.length - 1]._openMs + 1;
      // ç®€å•ä¿æŠ¤ï¼šæœ€å¤š 5000 æ ¹ï¼Œé¿å…è¿‡é•¿å¾ªç¯
      if (out.length >= 5000) break;
      // è½»å¾®èŠ‚æµï¼Œé¿å… 429
      await sleep(200);
    }
  }

  return out;
}

async function fetchCryptoCandlesSmart(base, quote, { interval='1d', want=120 } = {}){
  try {
    // ç›´æ¥ä» Binance æ‹‰æœ€è¿‘ want æ ¹ï¼ˆä¸€æ¬¡å³å¯ï¼‰
    const arr = await fetchCryptoCandlesFromBinance(base, quote, { interval, limit: want });
    if (arr?.length) return arr.slice(-want);
  } catch(e){
    console.warn('Binance candles failed, fallback to AV:', e?.message || e);
  }
  // å›é€€ AV æ—¥çº¿ï¼ˆæˆ‘ä»¬å·²æœ‰ avPickOHLC / fetchCryptoDailyï¼‰
  const avMarket = (quote === 'USDT') ? 'USD' : quote;
  const daily = await fetchCryptoDaily(base, avMarket);
  if (!daily) return null;
  const dates = Object.keys(daily).sort(); // oldest -> newest
  const out = dates.map(d => {
    const ohlc = avPickOHLC(daily[d], avMarket);
    return { t:d, o:+ohlc.open, h:+ohlc.high, l:+ohlc.low, c:+ohlc.close, v:+(daily[d]['5. volume']||0) };
  });
  return out.slice(-want);
}


/* ---- è·å– K çº¿ï¼šStock ç”¨ AV æ—¥çº¿ï¼ˆè‡ªå¸¦ä½ ä¹‹å‰åŠ çš„é™æµ/ç¼“å­˜ï¼‰---- */
// ä» Alpha Vantage è·å–è‚¡ç¥¨Kçº¿ï¼šä¼˜å…ˆæ—¥çº¿ï¼Œå¤±è´¥åˆ™å›é€€åˆ°å‘¨çº¿ï¼ˆæ›´æŠ—é™æµï¼‰
async function fetchStockDaily(symbol){
  // ä¼˜å…ˆï¼šæ—¥çº¿ï¼ˆTIME_SERIES_DAILY_ADJUSTEDï¼‰
  try {
    const data = await avFetchJson(
      { function: 'TIME_SERIES_DAILY_ADJUSTED', symbol },
      `tsda:${symbol}`,
      5 * 60_000
    );
    const ts = data && data['Time Series (Daily)'];
    if (ts) {
      const dates = Object.keys(ts).sort(); // oldest -> newest
      return dates.map(d => {
        const row = ts[d];
        return {
          t: d,
          o: +row['1. open'],
          h: +row['2. high'],
          l: +row['3. low'],
          c: +row['4. close'],
          v: +(row['6. volume'] || row['5. volume'] || 0),
          _tf: 'D'
        };
      });
    }
  } catch (e) {
    console.warn('AV daily failed:', e?.message || e);
  }

  // å›é€€ï¼šå‘¨çº¿ï¼ˆTIME_SERIES_WEEKLY_ADJUSTEDï¼‰
  try {
    const data = await avFetchJson(
      { function: 'TIME_SERIES_WEEKLY_ADJUSTED', symbol },
      `tswa:${symbol}`,
      10 * 60_000
    );
    const ts = data && (data['Weekly Adjusted Time Series'] || data['Weekly Time Series']);
    if (!ts) return null;
    const dates = Object.keys(ts).sort(); // oldest -> newest
    return dates.map(d => {
      const row = ts[d];
      return {
        t: d,
        o: +row['1. open'],
        h: +row['2. high'],
        l: +row['3. low'],
        c: +row['4. close'],
        v: +(row['6. volume'] || row['5. volume'] || 0),
        _tf: 'W'
      };
    });
  } catch (e) {
    console.warn('AV weekly failed:', e?.message || e);
    return null;
  }
}


/* ---- å¯¹å¤–è§¦å‘ï¼šå½“å‰æ ‡çš„ç”Ÿæˆè§£è¯» ---- */
function generateInsightsForStock(symbol){
  return explainFromSeriesCached(`ins_stock_${symbol}`, () => fetchStockDaily(symbol), symbol, 'stock');
}
function generateInsightsForCrypto(base, quote, interval='1d'){
  const label = `${base}/${quote}`;
  return explainFromSeriesCached(
    `ins_crypto_${label}_${interval}`,
    () => fetchCryptoCandlesSmart(base, quote, { interval, want: 120 }),
    `${label} (${interval})`,
    'crypto'
  );
}

/* ========= Retry helper for AI proxy ========= */
function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }
async function postChatWithRetry(body, { retries = 3, baseDelay = 800 } = {}) {
      for (let i = 0; i <= retries; i++) {
        const resp = await fetch(PROXY_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body)
        });
        const json = await resp.json().catch(() => ({}));

        // success
        if (resp.ok && !json.error) return json;

        // rate-limited â†’ backoff & retry
        if (resp.status === 429 && i < retries) {
          const retryAfter =
            Number(resp.headers.get("retry-after")) ||
            Number(json.retryAfter) || 0;
          const delay = retryAfter ? retryAfter * 1000 : baseDelay * Math.pow(2, i);
          console.warn(`429 rate limit, retry in ${delay}ms (attempt ${i+1}/${retries})`);
          await sleep(delay);
          continue;
        }

        // other errors â†’ throw
        throw { resp, json };
      }
      throw new Error("Exceeded retries");
    }

    /* ========= DOM ========= */
    const tabStocks   = document.getElementById('tab-stocks');
    const tabCrypto   = document.getElementById('tab-crypto');
    const panelStocks = document.getElementById('panel-stocks');
    const panelCrypto = document.getElementById('panel-crypto');
    const chartTitle  = document.getElementById('chart-title');

    const stockForm = document.getElementById('stock-form');
    const resultDiv = document.getElementById('result');
    const recGrid   = document.getElementById('rec-grid');
    const recStatus = document.getElementById('rec-status');

    const cryptoForm   = document.getElementById('crypto-form');
    const cryptoResult = document.getElementById('crypto-result');

    /* ========= Tabs ========= */
    function setActiveTab(which){
      if(which==='stocks'){
        tabStocks.classList.add('active'); tabCrypto.classList.remove('active');
        panelStocks.classList.remove('hidden'); panelCrypto.classList.add('hidden');
      } else {
        tabCrypto.classList.add('active'); tabStocks.classList.remove('active');
        panelCrypto.classList.remove('hidden'); panelStocks.classList.add('hidden');
      }
    }
    tabStocks.addEventListener('click', ()=>setActiveTab('stocks'));
    tabCrypto.addEventListener('click', ()=>setActiveTab('crypto'));

    /* ========= TradingView ========= */
    function renderTradingView(symbolLike){
      const container = document.getElementById('tv_chart_container');
      container.innerHTML = '';
      if (typeof TradingView === 'undefined' || !TradingView.widget) {
        container.innerHTML = '<div class="error">TradingView script failed to load.</div>';
        return;
      }
      new TradingView.widget({
        autosize: true,
        symbol: symbolLike,
        interval: "D",
        timezone: "Etc/UTC",
        theme: "light",
        style: "1",
        locale: "en",
        toolbar_bg: "#f1f3f6",
        enable_publishing: false,
        allow_symbol_change: true,
        container_id: "tv_chart_container"
      });
    }

    /* ========= Alpha Vantage: Stocks ========= */
    async function fetchQuote(symbol) {
      const url = `https://www.alphavantage.co/query?function=GLOBAL_QUOTE&symbol=${encodeURIComponent(symbol)}&apikey=${AV_API_KEY}`;
      const res = await fetch(url);
      const data = await res.json();
      return data && data['Global Quote'] && data['Global Quote']['01. symbol'] ? data['Global Quote'] : null;
    }
    function renderQuote(quote) {
      resultDiv.innerHTML = `
        <h2>${quote['01. symbol']}</h2>
        <p><strong>Price:</strong> $${quote['05. price']}</p>
        <p><strong>Open:</strong> $${quote['02. open']}</p>
        <p><strong>High:</strong> $${quote['03. high']}</p>
        <p><strong>Low:</strong> $${quote['04. low']}</p>
        <p><strong>Prev Close:</strong> $${quote['08. previous close']}</p>
        <p><strong>Change:</strong> ${quote['09. change']} (${quote['10. change percent']})</p>
      `;
    }

    /* ========= Alpha Vantage: Crypto ========= */
    async function fetchCryptoExchangeRate(base, quote){
      const url = `https://www.alphavantage.co/query?function=CURRENCY_EXCHANGE_RATE&from_currency=${encodeURIComponent(base)}&to_currency=${encodeURIComponent(quote)}&apikey=${AV_API_KEY}`;
      const res = await fetch(url);
      const data = await res.json();
      return data && data['Realtime Currency Exchange Rate'] ? data['Realtime Currency Exchange Rate'] : null;
    }
    async function fetchCryptoDaily(base, quote){
      const url = `https://www.alphavantage.co/query?function=DIGITAL_CURRENCY_DAILY&symbol=${encodeURIComponent(base)}&market=${encodeURIComponent(quote)}&apikey=${AV_API_KEY}`;
      const res = await fetch(url);
      const data = await res.json();
      return data && data['Time Series (Digital Currency Daily)'] ? data['Time Series (Digital Currency Daily)'] : null;
    }

    // Robust OHLC picker for AV Digital Currency Daily
    function avPickOHLC(dayObj, preferQuote = "USD") {
      const keys = Object.keys(dayObj || {});
      const pick = (part) => {
        const lc = part.toLowerCase();
        let key =
          keys.find(k => k.toLowerCase().includes(` ${lc} `) && k.endsWith(`(${preferQuote})`)) ||
          keys.find(k => k.toLowerCase().includes(` ${lc} `) && k.endsWith(`(USD)`)) ||
          keys.find(k => k.toLowerCase().includes(` ${lc} `));
        return key ? dayObj[key] : undefined;
      };
      return {
        open:  pick("open"),
        high:  pick("high"),
        low:   pick("low"),
        close: pick("close"),
      };
    }

    function renderCryptoQuote(base, quote, exRate, dailySeries){
      let ohlcHtml = '';
      if (dailySeries){
        const dates = Object.keys(dailySeries).sort().reverse(); // latest first
        if (dates.length){
          const d0 = dailySeries[dates[0]];
          // AV often only has USD series; prefer USD when quote is USDT
          const prefer = (quote === 'USDT') ? 'USD' : quote;
          const { open, high, low, close } = avPickOHLC(d0, prefer);
          if (open !== undefined) {
            ohlcHtml = `<p><strong>Daily (last):</strong> O ${open} â€¢ H ${high} â€¢ L ${low} â€¢ C ${close} (${dates[0]})</p>`;
          }
        }
      }
      const p   = exRate ? exRate['5. Exchange Rate'] : 'â€”';
      const t   = exRate ? exRate['6. Last Refreshed'] : 'â€”';
      const bid = exRate ? exRate['8. Bid Price'] : 'â€”';
      const ask = exRate ? exRate['9. Ask Price'] : 'â€”';

      cryptoResult.innerHTML = `
        <h2>${base}/${quote}</h2>
        <p><strong>Real-time:</strong> ${p} (${t})</p>
        <p><strong>Bid/Ask:</strong> ${bid} / ${ask}</p>
        ${ohlcHtml || `<p class="hint">No daily OHLC from Alpha Vantage for ${base}/${quote}.</p>`}
      `;
    }

    /* ========= Stocks: AI picks via proxy ========= */
    const UNIVERSE = ["AAPL","MSFT","NVDA","AMZN","GOOGL","META","TSLA","V","MA","JPM","HD","UNH"];

    // de-dupe + local cache (6h)
    let aiReqInFlight = false;
    const REC_CACHE_TTL = 6 * 60 * 60 * 1000; // 6 hours
    function loadCachedRecs(key){
      try {
        const raw = localStorage.getItem(key);
        if (!raw) return null;
        const { ts, data } = JSON.parse(raw);
        if (Date.now() - ts < REC_CACHE_TTL) return data;
      } catch {}
      return null;
    }
    function saveCachedRecs(key, data){
      try { localStorage.setItem(key, JSON.stringify({ ts: Date.now(), data })); } catch {}
    }

    async function getAIRecommendations(n = 4){
      if (aiReqInFlight) return [];
      aiReqInFlight = true;

      const CACHE_KEY = `ai_rec_${UNIVERSE.join("-")}_${n}`;
      const cached = loadCachedRecs(CACHE_KEY);
      if (cached) {
        aiReqInFlight = false;
        return cached;
      }

      const prompt = `
You are a stock screening assistant. From the following universe, pick ${n} tickers worth watching and give ONE short reason for each.
Return STRICT JSON only, no extra text or formatting.
Format: [{"symbol":"AAPL","reason":"New product cycle expected to drive growth"}]
Universe: ${UNIVERSE.join(", ")}
`.trim();

      try {
        const json = await postChatWithRetry({
          model: OPENAI_MODEL,
          messages: [{ role: "user", content: prompt }],
          temperature: 0.7
        }, { retries: 3, baseDelay: 800 });

        const list = JSON.parse(json?.choices?.[0]?.message?.content || "[]");
        if (Array.isArray(list) && list.length) saveCachedRecs(CACHE_KEY, list);
        return list;
      } catch (e) {
        console.error("AI proxy error:", e?.json || e);
        recStatus.textContent = `AI error: ${
          e?.json?.error || e?.json?.payload?.error?.message || e?.resp?.status || "unknown"
        }`;
        return [];
      } finally {
        aiReqInFlight = false;
      }
    }

    function renderRecommendations(list){
      recGrid.innerHTML="";
      list.forEach(item=>{
        const card=document.createElement("div");
        card.className="rec-card";
        card.innerHTML=`<div class="rec-symbol">${item.symbol}</div><div class="rec-reason">${item.reason||""}</div>`;
        card.addEventListener("click", async ()=>{
  const symbol=item.symbol.toUpperCase();
  document.getElementById('symbol').value=symbol;

  chartTitle.textContent = `${symbol} â€¢ Stock Chart`;
  renderTradingView(symbol);

  // AI è§£è¯»
  generateInsightsForStock(symbol);

  resultDiv.textContent="Loading quote...";
  try {
    const quote=await fetchQuote(symbol);
    if(quote){ renderQuote(quote); }
    else { resultDiv.innerHTML = `<span class="error">No data for ${symbol}</span>`; }
  } catch (err){
    console.error(err);
    resultDiv.innerHTML = `<span class="error">${err?.message || 'Error fetching quote.'}</span>`;
  }
  window.scrollTo({top:document.querySelector('.tv-wrap').offsetTop-16,behavior:'smooth'});
});

        recGrid.appendChild(card);
      });
    }

    /* ========= Init ========= */
    document.addEventListener('DOMContentLoaded', async ()=>{
      // default: AAPL chart
      chartTitle.textContent = 'AAPL â€¢ Stock Chart';
      renderTradingView("AAPL");

      // AI picks
      try{
        let recs = await getAIRecommendations(4);
        if(recs.length){
          renderRecommendations(recs);
          recStatus.textContent="Loaded AI picks";
        } else {
          recStatus.textContent="Loaded fallback picks";
          renderRecommendations(UNIVERSE.slice(0,4).map(s=>({symbol:s,reason:"High market attention"})));
        }
      }catch{
        recStatus.textContent="AI unavailable";
      }
    });

    /* ========= Events ========= */
    stockForm.addEventListener('submit', async (e)=>{
  e.preventDefault();
  const symbol = document.getElementById('symbol').value.trim().toUpperCase();
  if(!symbol) return;

  // å…ˆåˆ‡å›¾
  chartTitle.textContent = `${symbol} â€¢ Stock Chart`;
  renderTradingView(symbol);

  // è§¦å‘ AI è§£è¯»ï¼ˆä¸ä¾èµ–æŠ¥ä»·ï¼‰
  generateInsightsForStock(symbol);

  // å†å¼‚æ­¥å–æŠ¥ä»·
  resultDiv.textContent="Loading quote...";
  try {
    const quote=await fetchQuote(symbol);
    if(quote){ renderQuote(quote); }
    else { resultDiv.innerHTML = `<span class="error">No data for ${symbol}</span>`; }
  } catch(err){
    console.error(err);
    resultDiv.innerHTML = `<span class="error">${err?.message || 'Error fetching quote.'}</span>`;
  }
});


    cryptoForm.addEventListener('submit', async (e)=>{
  e.preventDefault();
  const base  = document.getElementById('cryptoSymbol').value.trim().toUpperCase();
  const quote = document.getElementById('cryptoMarket').value.trim().toUpperCase();
  const exSel = document.getElementById('cryptoExchange').value;
  if(!base || !quote) return;

  // å…ˆåˆ‡ TradingView å›¾
  let tvSymbol = '';
  if (exSel === 'COINBASE') {
    const q = (quote === 'USDT') ? 'USD' : quote;
    tvSymbol = `COINBASE:${base}${q}`;
  } else {
    const q = (quote === 'USD') ? 'USDT' : quote;
    tvSymbol = `BINANCE:${base}${q}`;
  }
  chartTitle.textContent = `${base}/${quote} â€¢ Crypto Chart`;
  renderTradingView(tvSymbol);

  // AI è§£è¯»ï¼ˆä¸ä¾èµ– AVï¼‰
  generateInsightsForCrypto(base, quote, '1d');


  // å†å¼‚æ­¥å–æ±‡ç‡/æ—¥çº¿ï¼ˆå¯è¢« AV é™æµï¼Œä½†ä¸å½±å“ä¸Šé¢ä¸¤æ­¥ï¼‰
  cryptoResult.textContent = 'Loading...';
  try {
    const exRate = await fetchCryptoExchangeRate(base, quote);
    const avMarket = (quote === 'USDT') ? 'USD' : quote;
    const daily = await fetchCryptoDaily(base, avMarket);
    renderCryptoQuote(base, quote, exRate, daily);
  } catch(err){
    console.error(err);
    cryptoResult.innerHTML = `<span class="error">${err?.message || 'Error fetching crypto data.'}</span>`;
  }
});

  </script>
</body>
</html>